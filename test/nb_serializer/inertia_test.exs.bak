defmodule NbSerializer.InertiaTest do
  use ExUnit.Case, async: true
  import Plug.Test
  import Plug.Conn

  import NbSerializer.Inertia
  import Inertia.Controller
  import Inertia.Testing

  defmodule User do
    defstruct [:id, :name, :email, :role]
  end

  defmodule Post do
    defstruct [:id, :title, :body, :author_id]
  end

  defmodule UserSerializer do
    use NbSerializer.Serializer

    schema do
      field(:id)
      field(:name)
      field(:email)
      field(:role, if: :include_role?)
    end

    def include_role?(_, opts), do: opts[:include_role] == true
  end

  defmodule PostSerializer do
    use NbSerializer.Serializer

    schema do
      field(:id)
      field(:title)
      field(:body)
    end
  end

  defmodule StatsSerializer do
    use NbSerializer.Serializer

    schema do
      field(:total_users)
      field(:total_posts)
    end
  end

  # Helper to create a test connection with Inertia setup
  defp test_conn do
    conn(:get, "/")
    |> Map.put(:params, %{"_format" => "html"})
    |> Plug.Test.init_test_session(%{})
    |> Phoenix.Controller.fetch_flash([])
    |> put_private(:phoenix_endpoint, NbSerializer.InertiaTest.FakeEndpoint)
    |> Inertia.Plug.call([])
  end

  defmodule FakeEndpoint do
    def url, do: "http://localhost:4000"
    def static_path(path), do: path
  end

  describe "assign_serialized/4" do
    test "serializes data using the provided serializer" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      conn =
        test_conn()
        |> assign_serialized(:user, UserSerializer, user)
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:user][:id] == 1
      assert props[:user][:name] == "John Doe"
      assert props[:user][:email] == "john@example.com"
    end

    test "passes serialization options to the serializer" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      conn =
        test_conn()
        |> assign_serialized(:user, UserSerializer, user, opts: [include_role: true])
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:user][:role] == :admin
    end

    test "supports lazy evaluation with lazy: true" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      conn =
        test_conn()
        |> assign_serialized(:user, UserSerializer, user, lazy: true)
        |> render_inertia("Dashboard")

      # Lazy props should still be evaluated on first visit
      props = inertia_props(conn)
      assert props[:user][:id] == 1
    end

    test "supports optional props with optional: true" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      conn =
        test_conn()
        |> assign_serialized(:user, UserSerializer, user, optional: true)
        |> render_inertia("Dashboard")

      # Optional props should not be included on first visit
      props = inertia_props(conn)
      refute Map.has_key?(props, :user)
    end

    test "supports deferred props with defer: true" do
      stats = %{total_users: 100, total_posts: 500}

      conn =
        test_conn()
        |> assign_serialized(:stats, StatsSerializer, stats, defer: true)
        |> render_inertia("Dashboard")

      # Deferred props work but may not be in initial props
      # The key functionality is that assign_serialized doesn't error
      assert conn.status == 200
    end

    test "supports deferred props with group name" do
      stats = %{total_users: 100, total_posts: 500}

      conn =
        test_conn()
        |> assign_serialized(:stats, StatsSerializer, stats, defer: "metrics")
        |> render_inertia("Dashboard")

      # Deferred props work but may not be in initial props
      # The key functionality is that assign_serialized doesn't error
      assert conn.status == 200
    end

    test "supports merge props with merge: true" do
      posts = [
        %Post{id: 1, title: "Post 1", body: "Content 1", author_id: 1},
        %Post{id: 2, title: "Post 2", body: "Content 2", author_id: 1}
      ]

      conn =
        test_conn()
        |> assign_serialized(:posts, PostSerializer, posts, merge: true)
        |> render_inertia("Feed")

      # Merge props should be included
      props = inertia_props(conn)
      assert length(props[:posts]) == 2
    end

    test "supports deep merge with merge: :deep" do
      config = %{theme: "dark", settings: %{notifications: true}}

      conn =
        test_conn()
        |> assign_serialized(
          :config,
          (fn ->
             defmodule ConfigSerializer do
               use NbSerializer.Serializer

               schema do
                 field(:theme)
                 field(:settings)
               end
             end

             ConfigSerializer
           end).(),
          config,
          merge: :deep
        )
        |> render_inertia("Settings")

      # Deep merge props should be included
      props = inertia_props(conn)
      assert props[:config][:theme] == "dark"
    end

    test "combines lazy and serialization options" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      conn =
        test_conn()
        |> assign_serialized(:user, UserSerializer, user,
          lazy: true,
          opts: [include_role: true]
        )
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:user][:role] == :admin
    end

    test "handles serialization errors" do
      # Test that serialization errors are raised
      defmodule BrokenSerializer do
        use NbSerializer.Serializer

        schema do
          field(:value, compute: :broken_function)
        end

        def broken_function(_data, _opts) do
          raise "Intentional error"
        end
      end

      assert_raise NbSerializer.SerializationError, fn ->
        test_conn()
        |> assign_serialized(:broken, BrokenSerializer, %{})
        |> render_inertia("Dashboard")
      end
    end
  end

  describe "assign_serialized_errors/2" do
    test "assigns errors from Ecto changeset" do
      # Create a fake changeset with errors
      types = %{name: :string, email: :string}
      params = %{}

      changeset =
        {%{}, types}
        |> Ecto.Changeset.cast(params, Map.keys(types))
        |> Ecto.Changeset.validate_required([:name, :email])

      conn =
        test_conn()
        |> assign_serialized_errors(changeset)
        |> render_inertia("Form")

      errors = inertia_errors(conn)
      assert errors[:name] == "can't be blank"
      assert errors[:email] == "can't be blank"
    end

    test "assigns errors from error map" do
      errors = %{
        name: "Name is required",
        email: "Email is invalid"
      }

      conn =
        test_conn()
        |> assign_serialized_errors(errors)
        |> render_inertia("Form")

      result_errors = inertia_errors(conn)
      assert result_errors[:name] == "Name is required"
      assert result_errors[:email] == "Email is invalid"
    end
  end

  describe "assign_serialized_props/2" do
    test "assigns multiple props at once" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      posts = [
        %Post{id: 1, title: "Post 1", body: "Content 1", author_id: 1}
      ]

      conn =
        test_conn()
        |> assign_serialized_props(
          user: {UserSerializer, user},
          posts: {PostSerializer, posts}
        )
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:user][:id] == 1
      assert length(props[:posts]) == 1
    end

    test "supports options for each prop" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}
      posts = [%Post{id: 1, title: "Post 1", body: "Content 1", author_id: 1}]

      conn =
        test_conn()
        |> assign_serialized_props(
          user: {UserSerializer, user, opts: [include_role: true]},
          posts: {PostSerializer, posts, lazy: true}
        )
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:user][:role] == :admin
      assert length(props[:posts]) == 1
    end

    test "raises error for invalid prop format" do
      assert_raise ArgumentError, ~r/Expected prop value to be/, fn ->
        test_conn()
        |> assign_serialized_props(invalid: "not a tuple")
        |> render_inertia("Dashboard")
      end
    end
  end

  describe "render_inertia_serialized/3" do
    test "renders Inertia response with serialized props" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      conn =
        test_conn()
        |> render_inertia_serialized("Dashboard",
          user: {UserSerializer, user}
        )

      assert inertia_component(conn) == "Dashboard"
      props = inertia_props(conn)
      assert props[:user][:id] == 1
    end

    test "supports multiple props with options" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}
      posts = [%Post{id: 1, title: "Post 1", body: "Content 1", author_id: 1}]
      stats = %{total_users: 100, total_posts: 500}

      conn =
        test_conn()
        |> render_inertia_serialized("Dashboard",
          user: {UserSerializer, user, opts: [include_role: true]},
          posts: {PostSerializer, posts, lazy: true},
          stats: {StatsSerializer, stats, defer: true}
        )

      assert inertia_component(conn) == "Dashboard"
      props = inertia_props(conn)
      assert props[:user][:role] == :admin
      assert length(props[:posts]) == 1
      # Deferred props may not be in initial response
      assert conn.status == 200
    end

    test "renders without props" do
      conn =
        test_conn()
        |> render_inertia_serialized("Dashboard")

      assert inertia_component(conn) == "Dashboard"
    end
  end

  describe "integration with Inertia features" do
    test "works with regular assign_prop for mixed prop types" do
      user = %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin}

      conn =
        test_conn()
        |> assign_serialized(:user, UserSerializer, user)
        |> assign_prop(:raw_count, 42)
        |> assign_prop(:message, "Hello")
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:user][:id] == 1
      assert props[:raw_count] == 42
      assert props[:message] == "Hello"
    end

    test "serializes collections" do
      users = [
        %User{id: 1, name: "John Doe", email: "john@example.com", role: :admin},
        %User{id: 2, name: "Jane Smith", email: "jane@example.com", role: :user}
      ]

      conn =
        test_conn()
        |> assign_serialized(:users, UserSerializer, users)
        |> render_inertia("Users/Index")

      props = inertia_props(conn)
      assert length(props[:users]) == 2
      assert Enum.at(props[:users], 0)[:name] == "John Doe"
      assert Enum.at(props[:users], 1)[:name] == "Jane Smith"
    end

    test "handles nil data gracefully" do
      conn =
        test_conn()
        |> assign_serialized(:user, UserSerializer, nil)
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:user] == nil
    end

    test "handles empty collections" do
      conn =
        test_conn()
        |> assign_serialized(:posts, PostSerializer, [])
        |> render_inertia("Dashboard")

      props = inertia_props(conn)
      assert props[:posts] == []
    end
  end

  describe "inertia_page/2 macro with atom-based page references" do
    test "declares a page with inferred component name" do
      defmodule UsersIndexController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
        end
      end

      assert UsersIndexController.page(:users_index) == "Users/Index"
    end

    test "declares a page with explicit component name override" do
      defmodule ProfileController do
        use NbSerializer.Inertia.Controller

        inertia_page :user_profile, component: "UserProfile" do
          prop(:user, UserSerializer)
        end
      end

      assert ProfileController.page(:user_profile) == "UserProfile"
    end

    test "raises error for undeclared page" do
      defmodule ErrorPageController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
        end
      end

      assert_raise ArgumentError, ~r/Inertia page :nonexistent not declared/, fn ->
        ErrorPageController.page(:nonexistent)
      end
    end

    test "stores prop declarations for a page" do
      defmodule PropsPageController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
          prop(:total_count, :integer)
          prop(:filters, PostSerializer, lazy: true)
        end
      end

      config = PropsPageController.inertia_page_config(:users_index)

      assert config.component == "Users/Index"
      assert length(config.props) == 3

      users_prop = Enum.find(config.props, &(&1.name == :users))
      assert users_prop.serializer == UserSerializer

      count_prop = Enum.find(config.props, &(&1.name == :total_count))
      assert count_prop.type == :integer

      filters_prop = Enum.find(config.props, &(&1.name == :filters))
      assert filters_prop.opts[:lazy] == true
    end

    test "supports multiple pages in same controller" do
      defmodule MultiPageController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
        end

        inertia_page :users_show do
          prop(:user, UserSerializer)
          prop(:posts, PostSerializer, lazy: true)
        end
      end

      assert MultiPageController.page(:users_index) == "Users/Index"
      assert MultiPageController.page(:users_show) == "Users/Show"

      index_config = MultiPageController.inertia_page_config(:users_index)
      assert length(index_config.props) == 1

      show_config = MultiPageController.inertia_page_config(:users_show)
      assert length(show_config.props) == 2
    end
  end

  describe "Inertia.Controller function availability" do
    test "all Inertia.Controller functions are available via use NbSerializer.Inertia.Controller" do
      # This test verifies that all Inertia.Controller functions compile successfully
      # when using NbSerializer.Inertia.Controller
      defmodule AllFunctionsController do
        use NbSerializer.Inertia.Controller

        inertia_page :test do
          prop(:data, :string)
        end

        def test_compilation(_conn) do
          # Test that all these functions are available at compile time
          _optional = inertia_optional(fn -> "test" end)
          _defer1 = inertia_defer(fn -> "test" end)
          _defer2 = inertia_defer(fn -> "test" end, "group")
          _merge = inertia_merge("test")
          _deep = inertia_deep_merge("test")
          _always = inertia_always("test")
          _preserve = preserve_case(:key)

          # These compile successfully, proving the functions are imported
          :ok
        end
      end

      # If this compiles, all functions are available
      assert AllFunctionsController.test_compilation(nil) == :ok
    end

    test "assign_prop works with our overridden render_inertia" do
      defmodule AssignPropTest do
        use NbSerializer.Inertia.Controller

        inertia_page :test do
          prop(:value, :integer)
        end

        def action(conn) do
          conn
          |> assign_prop(:value, 42)
          |> render_inertia(:test, value: 42)
        end
      end

      conn = test_conn()
      result = AssignPropTest.action(conn)
      assert result.private[:inertia_page]
    end

    test "assign_errors works" do
      defmodule AssignErrorsTest do
        use NbSerializer.Inertia.Controller

        inertia_page :test do
          prop(:data, :string)
        end

        def action(conn) do
          conn
          |> assign_errors(%{email: "is required"})
          |> render_inertia(:test, data: "test")
        end
      end

      conn = test_conn()
      result = AssignErrorsTest.action(conn)
      # Errors are in the props as per Inertia's design
      assert result.private[:inertia_page].props[:errors]
    end

    test "camelize_props works" do
      defmodule CamelizeTest do
        use NbSerializer.Inertia.Controller

        inertia_page :test do
          prop(:data, :string)
        end

        def action(conn) do
          conn
          |> camelize_props(true)
          |> render_inertia(:test, data: "test")
        end
      end

      conn = test_conn()
      result = CamelizeTest.action(conn)
      assert result.private[:inertia_camelize_props] == true
    end

    test "automatic camelization when configured" do
      # Temporarily enable camelization
      original_config = Application.get_env(:nb_serializer, :camelize_props)
      Application.put_env(:nb_serializer, :camelize_props, true)

      try do
        defmodule AutoCamelizeTest do
          use NbSerializer.Inertia.Controller

          inertia_page :test do
            prop(:user_name, :string)
            prop(:total_count, :integer)
          end

          def action(conn) do
            render_inertia(conn, :test, user_name: "John", total_count: 42)
          end
        end

        conn = test_conn()
        result = AutoCamelizeTest.action(conn)

        # Should be automatically camelized
        assert result.private[:inertia_camelize_props] == true

        # Props should be camelCase (they get converted by Inertia)
        props = inertia_props(result)
        # After camelization, keys become strings
        assert props["userName"] == "John" || props[:userName] == "John"
        assert props["totalCount"] == 42 || props[:totalCount] == 42
      after
        # Restore original config
        if original_config == nil do
          Application.delete_env(:nb_serializer, :camelize_props)
        else
          Application.put_env(:nb_serializer, :camelize_props, original_config)
        end
      end
    end
  end

  describe "introspection for mix tasks" do
    test "__inertia_pages__/0 returns all page configurations" do
      defmodule IntrospectionController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
          prop(:total_count, :integer)
        end

        inertia_page :user_show, component: "CustomComponent" do
          prop(:user, UserSerializer)
        end

        inertia_page :dashboard do
          prop(:stats, StatsSerializer)
        end
      end

      assert function_exported?(IntrospectionController, :__inertia_pages__, 0)

      pages = IntrospectionController.__inertia_pages__()

      assert is_map(pages)
      assert map_size(pages) == 3

      # Verify page configurations
      assert pages[:users_index].component == "Users/Index"
      assert length(pages[:users_index].props) == 2

      assert pages[:user_show].component == "CustomComponent"
      assert length(pages[:user_show].props) == 1

      assert pages[:dashboard].component == "Dashboard"
      assert length(pages[:dashboard].props) == 1
    end

    test "__inertia_pages__/0 includes prop metadata" do
      defmodule PropMetadataController do
        use NbSerializer.Inertia.Controller

        inertia_page :test_page do
          prop(:required_field, UserSerializer)
          prop(:optional_field, :string, optional: true)
          prop(:lazy_field, PostSerializer, lazy: true)
        end
      end

      pages = PropMetadataController.__inertia_pages__()
      props = pages[:test_page].props

      assert length(props) == 3

      # Check that prop metadata is preserved
      required = Enum.find(props, &(&1.name == :required_field))
      assert required.serializer == UserSerializer
      assert Keyword.get(required.opts, :optional, false) == false

      optional = Enum.find(props, &(&1.name == :optional_field))
      assert optional.type == :string
      assert Keyword.get(optional.opts, :optional) == true

      lazy = Enum.find(props, &(&1.name == :lazy_field))
      assert lazy.serializer == PostSerializer
      assert Keyword.get(lazy.opts, :lazy) == true
    end
  end

  describe "component name inference" do
    test "infers component names from common CRUD action atoms" do
      assert NbSerializer.Inertia.ComponentNaming.infer(:users_index) == "Users/Index"
      assert NbSerializer.Inertia.ComponentNaming.infer(:users_show) == "Users/Show"
      assert NbSerializer.Inertia.ComponentNaming.infer(:users_new) == "Users/New"
      assert NbSerializer.Inertia.ComponentNaming.infer(:users_edit) == "Users/Edit"
      assert NbSerializer.Inertia.ComponentNaming.infer(:users_create) == "Users/Create"
    end

    test "handles single word page names" do
      assert NbSerializer.Inertia.ComponentNaming.infer(:dashboard) == "Dashboard"
      assert NbSerializer.Inertia.ComponentNaming.infer(:profile) == "Profile"
      assert NbSerializer.Inertia.ComponentNaming.infer(:settings) == "Settings"
    end

    test "handles common namespace prefixes" do
      assert NbSerializer.Inertia.ComponentNaming.infer(:admin_dashboard) == "Admin/Dashboard"
      assert NbSerializer.Inertia.ComponentNaming.infer(:admin_users_index) == "Admin/Users/Index"
      assert NbSerializer.Inertia.ComponentNaming.infer(:api_posts_show) == "Api/Posts/Show"
    end

    test "handles page names without standard action suffixes" do
      assert NbSerializer.Inertia.ComponentNaming.infer(:user_profile) == "UserProfile"
      assert NbSerializer.Inertia.ComponentNaming.infer(:edit_profile) == "EditProfile"
    end
  end

  describe "render_inertia_serialized/3 with atom page reference" do
    defmodule AtomReferenceController do
      use NbSerializer.Inertia.Controller
      import Plug.Conn

      inertia_page :users_index do
        prop(:users, UserSerializer)
        prop(:total_count, :integer)
      end

      inertia_page :users_show do
        prop(:user, UserSerializer)
      end

      def index(conn) do
        users = [%User{id: 1, name: "Alice", email: "alice@example.com", role: :admin}]

        render_inertia_serialized(conn, :users_index,
          users: {UserSerializer, users},
          total_count: 1
        )
      end

      def show(conn) do
        user = %User{id: 1, name: "Alice", email: "alice@example.com", role: :admin}

        render_inertia_serialized(conn, :users_show, user: {UserSerializer, user})
      end
    end

    test "renders with correct component name from atom reference" do
      conn = test_conn()
      conn = AtomReferenceController.index(conn)

      assert inertia_component(conn) == "Users/Index"
    end

    test "serializes props correctly with atom reference" do
      conn = test_conn()
      conn = AtomReferenceController.index(conn)

      props = inertia_props(conn)
      assert length(props[:users]) == 1
      assert props[:total_count] == 1
    end
  end

  describe "compile-time prop validation" do
    test "validates that all declared props are provided in dev mode" do
      defmodule MissingPropController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
          prop(:total_count, :integer)
        end

        def index_missing_prop(conn) do
          # Missing required :total_count
          render_inertia_serialized(conn, :users_index, users: {UserSerializer, []})
        end
      end

      conn = test_conn()

      assert_raise ArgumentError, ~r/Missing required props.*:total_count/s, fn ->
        MissingPropController.index_missing_prop(conn)
      end
    end

    test "warns about undeclared props in dev mode" do
      defmodule ExtraPropController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
        end

        def index_extra_prop(conn) do
          # :extra_prop not declared
          render_inertia_serialized(conn, :users_index,
            users: {UserSerializer, []},
            extra_prop: {PostSerializer, []}
          )
        end
      end

      conn = test_conn()

      assert_raise ArgumentError, ~r/Undeclared props.*:extra_prop/s, fn ->
        ExtraPropController.index_extra_prop(conn)
      end
    end

    test "allows optional props to be omitted" do
      defmodule OptionalPropController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
          prop(:filters, PostSerializer, optional: true)
        end

        def index_without_optional(conn) do
          render_inertia_serialized(conn, :users_index, users: {UserSerializer, []})
        end
      end

      conn = test_conn()
      conn = OptionalPropController.index_without_optional(conn)

      assert inertia_component(conn) == "Users/Index"
    end
  end

  describe "inertia_shared/1 macro for shared props" do
    test "declares shared props available across all pages" do
      defmodule SharedPropsController do
        use NbSerializer.Inertia.Controller

        inertia_shared do
          prop(:current_scope, UserSerializer, from: :assigns)
          prop(:flash, from: :assigns)
        end

        inertia_page :dashboard do
          prop(:stats, StatsSerializer)
        end
      end

      shared = SharedPropsController.inertia_shared_props()

      assert length(shared) == 2

      user_prop = Enum.find(shared, &(&1.name == :current_scope))
      assert user_prop.serializer == UserSerializer
      assert user_prop.from == :assigns

      flash_prop = Enum.find(shared, &(&1.name == :flash))
      assert flash_prop.from == :assigns
    end

    test "includes shared props in page renders automatically" do
      defmodule AutoSharedPropsController do
        use NbSerializer.Inertia.Controller
        import Plug.Conn

        inertia_shared do
          prop(:current_scope, UserSerializer, from: :assigns)
        end

        inertia_page :dashboard do
          prop(:stats, StatsSerializer)
        end

        def dashboard(conn) do
          conn
          |> assign(:current_scope, %User{
            id: 1,
            name: "Alice",
            email: "alice@example.com",
            role: :admin
          })
          |> render_inertia_serialized(:dashboard,
            stats: {StatsSerializer, %{total_users: 100, total_posts: 500}}
          )
        end
      end

      conn = test_conn()
      conn = AutoSharedPropsController.dashboard(conn)

      props = inertia_props(conn)
      assert props[:current_scope][:id] == 1
      assert props[:stats][:total_users] == 100
    end
  end

  describe "render_inertia/3 with atom page references (all-in-one with validation)" do
    defmodule AllInOneController do
      use NbSerializer.Inertia.Controller
      import Plug.Conn

      inertia_page :users_index do
        prop(:users, UserSerializer)
        prop(:total_count, :integer)
      end

      inertia_page :users_show do
        prop(:user, UserSerializer)
        prop(:posts, PostSerializer, optional: true)
      end

      inertia_shared do
        prop(:current_scope, UserSerializer, from: :assigns)
      end

      def index_all_in_one(conn) do
        users = [%User{id: 1, name: "Alice", email: "alice@example.com", role: :admin}]

        conn
        |> assign(:current_scope, %User{
          id: 99,
          name: "Admin",
          email: "admin@example.com",
          role: :admin
        })
        |> render_inertia(:users_index,
          users: {UserSerializer, users},
          total_count: 1
        )
      end

      def show_all_in_one(conn) do
        user = %User{id: 1, name: "Alice", email: "alice@example.com", role: :admin}

        conn
        |> assign(:current_scope, %User{
          id: 99,
          name: "Admin",
          email: "admin@example.com",
          role: :admin
        })
        |> render_inertia(:users_show,
          user: {UserSerializer, user}
          # posts omitted - optional prop
        )
      end
    end

    test "renders with validation" do
      conn = test_conn()
      conn = AllInOneController.index_all_in_one(conn)

      assert inertia_component(conn) == "Users/Index"
      props = inertia_props(conn)
      assert length(props[:users]) == 1
      assert props[:total_count] == 1
    end

    test "includes shared props automatically" do
      conn = test_conn()
      conn = AllInOneController.index_all_in_one(conn)

      props = inertia_props(conn)
      assert props[:current_scope][:id] == 99
    end

    test "validates required props" do
      defmodule ValidationController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
          prop(:total_count, :integer)
        end

        def missing_prop(conn) do
          render_inertia(conn, :users_index,
            users: {UserSerializer, []}
            # Missing total_count
          )
        end
      end

      conn = test_conn()

      assert_raise ArgumentError, ~r/Missing required props.*:total_count/s, fn ->
        ValidationController.missing_prop(conn)
      end
    end

    test "validates against extra props" do
      defmodule ExtraPropsController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
        end

        def extra_props(conn) do
          render_inertia(conn, :users_index,
            users: {UserSerializer, []},
            extra: {PostSerializer, []}
          )
        end
      end

      conn = test_conn()

      assert_raise ArgumentError, ~r/Undeclared props.*:extra/s, fn ->
        ExtraPropsController.extra_props(conn)
      end
    end

    test "allows optional props to be omitted" do
      conn = test_conn()
      conn = AllInOneController.show_all_in_one(conn)

      assert inertia_component(conn) == "Users/Show"
      props = inertia_props(conn)
      assert props[:user][:id] == 1
      refute Map.has_key?(props, :posts)
    end

    test "supports mixed serialized and raw props" do
      defmodule MixedPropsController do
        use NbSerializer.Inertia.Controller

        inertia_page :dashboard do
          prop(:user, UserSerializer)
          prop(:count, :integer)
          prop(:flag, :boolean)
        end

        def mixed(conn) do
          render_inertia(conn, :dashboard,
            user:
              {UserSerializer, %User{id: 1, name: "Alice", email: "a@example.com", role: :admin}},
            count: 42,
            flag: true
          )
        end
      end

      conn = test_conn()
      conn = MixedPropsController.mixed(conn)

      props = inertia_props(conn)
      assert props[:user][:id] == 1
      assert props[:count] == 42
      assert props[:flag] == true
    end
  end

  describe "inertia_page with index_signature option" do
    test "stores index_signature: true in page config" do
      defmodule IndexSignatureController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index, index_signature: true do
          prop(:users, UserSerializer)
        end
      end

      config = IndexSignatureController.inertia_page_config(:users_index)
      assert config.index_signature == true
    end

    test "index_signature defaults to false when not specified" do
      defmodule NoIndexSignatureController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
        end
      end

      config = NoIndexSignatureController.inertia_page_config(:users_index)
      refute Map.get(config, :index_signature, false)
    end

    test "can explicitly set index_signature: false" do
      defmodule ExplicitFalseController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index, index_signature: false do
          prop(:users, UserSerializer)
        end
      end

      config = ExplicitFalseController.inertia_page_config(:users_index)
      assert config.index_signature == false
    end

    test "index_signature works with component override" do
      defmodule IndexSigWithComponentController do
        use NbSerializer.Inertia.Controller

        inertia_page :user_profile, component: "UserProfile", index_signature: true do
          prop(:user, UserSerializer)
        end
      end

      config = IndexSigWithComponentController.inertia_page_config(:user_profile)
      assert config.component == "UserProfile"
      assert config.index_signature == true
    end
  end

  describe "render_inertia/2 with atom page references (pipe-friendly)" do
    defmodule PipeFriendlyController do
      use NbSerializer.Inertia.Controller
      import Plug.Conn

      inertia_page :users_index do
        prop(:users, UserSerializer)
        prop(:total_count, :integer)
      end

      inertia_page :users_show do
        prop(:user, UserSerializer)
        prop(:posts, PostSerializer)
      end

      inertia_shared do
        prop(:current_scope, UserSerializer, from: :assigns)
      end

      def index_with_pipe(conn) do
        users = [%User{id: 1, name: "Alice", email: "alice@example.com", role: :admin}]

        conn
        |> assign(:current_scope, %User{
          id: 99,
          name: "Admin",
          email: "admin@example.com",
          role: :admin
        })
        |> assign_serialized(:users, UserSerializer, users)
        |> assign_prop(:total_count, 1)
        |> render_inertia(:users_index)
      end

      def show_with_pipe(conn) do
        user = %User{id: 1, name: "Alice", email: "alice@example.com", role: :admin}
        posts = [%Post{id: 1, title: "Post 1", body: "Content", author_id: 1}]

        conn
        |> assign(:current_scope, %User{
          id: 99,
          name: "Admin",
          email: "admin@example.com",
          role: :admin
        })
        |> assign_serialized(:user, UserSerializer, user)
        |> assign_serialized(:posts, PostSerializer, posts)
        |> render_inertia(:users_show)
      end

      def mixed_with_pipe(conn) do
        conn
        |> assign(:current_scope, %User{
          id: 99,
          name: "Admin",
          email: "admin@example.com",
          role: :admin
        })
        |> assign_serialized(:users, UserSerializer, [])
        |> assign_prop(:total_count, 0)
        |> render_inertia(:users_index)
      end
    end

    test "supports atom page reference with pipe operator" do
      conn = test_conn()
      conn = PipeFriendlyController.index_with_pipe(conn)

      assert inertia_component(conn) == "Users/Index"
    end

    test "correctly serializes props with pipe pattern" do
      conn = test_conn()
      conn = PipeFriendlyController.index_with_pipe(conn)

      props = inertia_props(conn)
      assert length(props[:users]) == 1
      assert props[:total_count] == 1
    end

    test "includes shared props automatically with pipe pattern" do
      conn = test_conn()
      conn = PipeFriendlyController.index_with_pipe(conn)

      props = inertia_props(conn)
      assert props[:current_scope][:id] == 99
      assert props[:current_scope][:name] == "Admin"
    end

    test "pipe pattern skips prop validation for flexibility" do
      defmodule PipeValidationController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
          prop(:total_count, :integer)
        end

        def partial_props_with_pipe(conn) do
          conn
          |> assign_serialized(:users, UserSerializer, [])
          # Can skip total_count with pipe pattern - validation happens at render_inertia_serialized
          |> render_inertia(:users_index)
        end
      end

      conn = test_conn()
      # Should not raise - pipe pattern is more flexible
      conn = PipeValidationController.partial_props_with_pipe(conn)
      assert inertia_component(conn) == "Users/Index"
    end

    test "allows string component names for backward compatibility" do
      defmodule BackwardCompatController do
        use NbSerializer.Inertia.Controller

        def with_string_component(conn) do
          conn
          |> assign_prop(:data, "test")
          |> render_inertia("CustomComponent")
        end
      end

      conn = test_conn()
      conn = BackwardCompatController.with_string_component(conn)

      assert inertia_component(conn) == "CustomComponent"
    end

    test "raises error for undeclared atom page reference" do
      defmodule UndeclaredAtomController do
        use NbSerializer.Inertia.Controller

        inertia_page :users_index do
          prop(:users, UserSerializer)
        end

        def with_undeclared_atom(conn) do
          conn
          |> assign_prop(:data, "test")
          |> render_inertia(:nonexistent_page)
        end
      end

      conn = test_conn()

      # Raises when trying to look up the component name
      assert_raise ArgumentError, ~r/Inertia page :nonexistent_page not declared/, fn ->
        UndeclaredAtomController.with_undeclared_atom(conn)
      end
    end

    test "works with multiple pages using pipe pattern" do
      conn = test_conn()
      conn = PipeFriendlyController.show_with_pipe(conn)

      assert inertia_component(conn) == "Users/Show"
      props = inertia_props(conn)
      assert props[:user][:id] == 1
      assert length(props[:posts]) == 1
    end

    test "works with mixed serialized and raw props" do
      conn = test_conn()
      conn = PipeFriendlyController.mixed_with_pipe(conn)

      props = inertia_props(conn)
      assert props[:users] == []
      assert props[:total_count] == 0
    end
  end
end
